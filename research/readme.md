# Research Directory

前提
- **対象データ**:16000件の商品データテーブルを準備
- **実行内容**:「ドリル」で類似度計算を実施し、その類似度でソート

## パフォーマンス検証

### 検証内容
- **`extension.sql`**: 拡張機能による直接的な類似度計算
  - `calculate_morpheme_score`関数を使用した素直な実装
- **`pureQuery.sql`**: SQLで同等の機能を実装したクエリ
  - 形態素解析は他の拡張機能（例：`mecab_dict`）でも実現可能ですが、この検証では自作の`to_morpheme_array`関数を使用
- **`pureQueryUsingMorColumn.sql`**: 形態素解析結果をテーブルに持たせたクエリ
  - 形態素解析結果をテーブルに持たせることで、類似度計算の負荷を軽減できます

#### クエリ実行
```
psql -d morpheme_funcs -f extension.sql -p 28813 --host /home/vscode/.pgrx
```

### パフォーマンス比較表

| ケース                           | 概要                                              | 推奨手法具体例          | 速度        | データ容量   | メリット                          | デメリット                        |
|----------------------------------|-------------------------------------------------|-----------------------|------------|-------------|----------------------------------|-----------------------------------|
| 手法1.形態素解析済みデータが利用可能(morpheme_scoreなし)   | 事前に形態素解析結果をテーブルに格納し、to_morpheme_arrayを用いて割合を算出する手法。ginインデックスを利用。 | pureQueryUsingMorColumn | 高速(440ms~470ms)       | 大きい      | 事前計算により計算負荷を軽減        | データを用意する必要がある。また、インデックスを保持するため更新時のコストが大きい                   |
| 手法2.リアルタイム形態素解析(morpheme_scoreあり)  | morpheme_scoreで生データ同士を比較する手法           | calcPureSqlOrder       | 充分高速(520ms~530ms)       | 中程度       | 実装がシンプル         | インデックスを活用できないため遅く、データが増えた場合に工夫が必要           |
| 手法3.リアルタイム形態素解析(morpheme_scoreなし)  | to_morpheme_arrayで生データ同士を比較する手法       | pureQuery              | 低速(4700ms~5000ms)       | 大きい       | インデックスを参照できる。textsearch_jaなどによる従来の形態素解析機能のみで実現可能。                   | 実装が複雑なわりに速くない。           |

## 考察

- `calculate_morpheme_score`関数を使用した手法はデータが少ない場合は充分に高速でシンプルな実装が可能。
- データが増えた場合は、形態素解析結果をテーブルに持たせる手法が有効。
  - ただし、データの更新が頻繁に行われる場合は、インデックスの更新コストとのトレードオフが発生
  - 対象のデータを予め絞り込むなどの工夫をすることで、走査対象のデータ量を減らし、計算負荷の実現は可能

### 今後やること
- `calculate_morpheme_score`側でインデックスを活用できれば、高速でかつシンプルな実装が可能なためその実装と検証
  - 内部実装に踏み込むためハードル高め